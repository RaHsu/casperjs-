## casper模块

### casper类
获取casper实例最简单的方法是使用模块的`create()`方法：
```js
var casper = require('casper').create();
```

您也可以自己检索主要功能并实例化：
```js
var casper = new require('casper').Casper();
```

> 提示
在这里了解[如何扩展Casper](http://docs.casperjs.org/en/latest/extending.html)。

Casper构造器和`create()`函数都接受一个标准的js对象作为选项参数：
```js
var casper = require('casper').create({
    verbose: true,
    logLevel: "debug"
});
```

### casper.options
选项对象可以被传递到Casper构造器中：
```js
var casper = require('casper').create({
    clientScripts:  [
        'includes/jquery.js',      // These two scripts will be injected in remote
        'includes/underscore.js'   // DOM on every request
    ],
    pageSettings: {
        loadImages:  false,        // The WebPage instance used by Casper will
        loadPlugins: false         // use these settings
    },
    logLevel: "info",              // Only "info" level messages will be logged
    verbose: true                  // log messages will be printed out to the console
});
```

您还可以在运行时更改选项:
```js
var casper = require('casper').create();
casper.options.waitTimeout = 1000;
```

下面是所有选项的详细信息：

#### clientScripts
**类型**：Array

**默认值**：[ ]

包含在加载的每个页面中脚本文件路径的集合。

#### exitOnError
**类型**：Boolean

**默认值**：true

设置当脚本抛出未捕获的错误时CasperJS是否必须退出。

#### httpStatusHandlers
**类型**：Object

**默认值**：{ }

设置当脚本抛出未捕获的错误时CasperJS是否必须退出。

#### logLevel
**类型**：string

**默认值**："error"

设置log等级。

#### onAlert
**类型**：Function

**默认值**：null

**调用方式** ：onAlert(Object Casper,String message)

当JavaScript alert()函数执行时调用的函数。

#### onDie
**类型**：Function

**默认值**：null

**调用方式** ：onDie(Object Casper,String message,String status)

当Casper#die()函数执行时调用的函数。

#### onError
**类型**：Function

**默认值**：null

**调用方式** ：onError(Object Casper,String msg,Array backtrace)

发生“错误”级别事件时调用的函数。

#### onLoadError
**类型**：Function

**默认值**：null

**调用方式** ：onLoadError(Object Casper,String requestUrl,String status)

当请求的资源不能被加载时调用的函数。

#### onPageInitialized
**类型**：Function

**默认值**：null

**调用方式** ：onPageInitialized(Object page)

WebPage实例初始化后调用的函数。

#### onResourceReceived
**类型**：Function

**默认值**：null

**调用方式** ：onResourceReceived(Object Casper, Object resource)

PhantomJS'WebPage＃onResourceReceived（）回调的代理方法，但当前的Casper实例作为第一个参数传递。

#### onResourceRequested
**类型**：Function

**默认值**：null

**调用方式** ：onResourceRequested(Object Casper, Object resource)

PhantomJS的WebPage代理方法＃onResourceRequested（）回调，但当前的Casper实例作为第一个参数传递。

#### onStepComplete
**类型**：Function

**默认值**：null

**调用方式** ：onStepComplete(Object Casper, stepResult)

当step函数执行完毕后执行的函数。

#### onStepTimeout
**类型**：Function

**默认值**：Function

**调用方式** ：onStepTimeout(Integer timeout, Integer stepNum)

当step函数执行时间超过stepTimeout选项的值（如果已设置）时执行的函数。
默认情况下，在超时时，脚本将退出显示错误，而在测试环境中，只会将错误添加到套件结果中。

#### onTimeout
**类型**：Function

**默认值**： Function

**调用方式** ：onTimeout(Integer timeout)

当脚本执行时间超过超时选项的值时执行的功能（如果有的话）。
默认情况下，在超时时，脚本将退出显示错误，而在测试环境中，只会将错误添加到套件结果中。

#### onWaitTimeout
**类型**：Function

**默认值**：Function

**调用方式** ：onWaitTimeout(Integer timeout)

当waitFor *函数执行时间超过waitTimeout选项的值（如果有）已被设置时执行的函数 。
默认情况下，在超时时，脚本将退出显示错误，而在测试环境中，只会将错误添加到套件结果中。

#### page
**类型**：WebPage

**默认值**：null

一个PhanthomJS网页实例。

> 警告
修改`page`的属性可能会导致一些Casper的特性无法工作。比如，修改`onUrlChanged`属性会导致`waitForUrl`特性无法工作。

#### pageSettings
**类型**： Object

**默认值**：{ }

PhantomJS的WebPage选项对象。可用的设置有：
- `javascriptEnabled`定义是否在页面中执行脚本（默认为true）
- `loadImages`定义是否加载内联图像
- `localToRemoteUrlAccessEnabled`定义本地资源（例如从文件）是否可以访问远程URL（默认为false）
- `userAgent`定义当网页请求资源时发送到服务器的用户代理
- `userName`设置用于HTTP认证的用户名
- `password`设置用于HTTP认证的密码
- `resourceTimeout`（以毫秒为单位）定义超时时间，所请求的资源将停止尝试并继续执行页面的其他部分。`onResourceTimeout`回调将在超时时被调用。`undefined`（默认值）表示默认gecko参数。

PhantomJS具体设置：
- `XSSAuditingEnabled`定义是否应监视跨站点脚本尝试的加载请求（默认为false）
- `webSecurityEnabled`定义是否应启用Web安全性（默认为true）

SlimerJS具体设置 :
- `allowMedia false`可以取消加载媒体（音频/视频）。默认值：true。 （仅限SlimerJS）
- `maxAuthAttempts`指示HTTP身份验证的最大尝试次数。 （SlimerJS 0.9）
- `plainTextAllContent true`表示`pages.plainText`返回所有内容，甚至脚本元素的内容，不可见元素等。默认值：false。

#### remoteScripts
**类型**： Array

**默认值**：[ ]

*版本1.0新增*

包含在加载的每个页面中远程脚本URL的集合。

#### safeLogs
**类型**： Boolean

**默认值**：true

*版本1.0新增*

当此选项设置为true时，默认情况下，在`<input type =“password”>`中输入的任何密码信息将在日志消息中被模糊化。将safeLog设置为false将以透明文本披露密码（不推荐）。

#### SilentErrors
**类型**： Boolean

**默认值**：false

启用此选项时，不会抛出捕获的步骤错误（尽管相关事件仍然发生）。在测试环境中大部分内部使用。

#### stepTimeout
**类型**： Number

**默认值**：null

`Max step timeout`的单位为毫秒，当设置时，每个定义的step函数都将在达到此超时值之前执行。

您可以定义`onStepTimeout( )`回调来捕获这种情况。默认情况下，脚本将会`die( )`并显示错误消息。

#### timeout
**类型**： Number

**默认值**：null

最大超时数（毫秒）。

#### verbose
**类型**： Boolean

**默认值**：false

实时输出`log`消息。


#### viewportSize
**类型**： Object

**默认值**：null

视口大小，例如{width：800，height：600}。

> 提示
PhantomJS附带的默认视口为400x300，CasperJS默认不会覆盖它。

#### retryTimeout
**类型**： Number

**默认值**：100

尝试之间的默认延迟，是与wait系函数配套的函数。

#### waitTimeout
**类型**： Number

**默认值**：100

默认等待超时的时间，是与wait系函数配套的函数。

### Casper 原型
#### back( )
**调用方式**：back( )

返回浏览器历史的上一页面。
```js
casper.start('http://foo.bar/1')
casper.thenOpen('http://foo.bar/2');
casper.thenOpen('http://foo.bar/3');
casper.back();
casper.run(function() {
    console.log(this.getCurrentUrl()); // 'http://foo.bar/2'
});
```
建议你一起看看[forward()](http://docs.casperjs.org/en/latest/modules/casper.html#forward)函数。

#### base64encode()
**调用方式**：base64encode(String url \[, String method, Object data\])

使用客户端XMLHttpRequest同步使用base64算法对资源进行编码。

>提示
我们不能使用window.btoa( )，因为它在PhantomJS使用的WebKit版本中不能运行。

示例：检索base64编码的Google logo 图像
```js
var base64logo = null;
casper.start('http://www.google.fr/', function() {
    base64logo = this.base64encode('http://www.google.fr/images/srpr/logo3w.png');
});

casper.run(function() {
    this.echo(base64logo).exit();
});
```

您还可以执行HTTP POST请求来检索要编码的内容:
```js
var base64contents = null;
casper.start('http://domain.tld/download.html', function() {
    base64contents = this.base64encode('http://domain.tld/', 'POST', {
        param1: 'foo',
        param2: 'bar'
    });
});

casper.run(function() {
    this.echo(base64contents).exit();
});
```

#### bypass( )
**调用方式**：bypass(Numbr nb)

*1.1版本新增*
绕过一定数量的导航步骤：
```js
casper.start();
casper.then(function() {
    // This step will be executed
});
casper.then(function() {
    this.bypass(2);
});
casper.then(function() {
    // This test won't be executed
});
casper.then(function() {
    // Nor this one
});
casper.run();
```

#### click( )
**调用方法**：click(String selector, \[Number|String X, Number|String Y\])

点击由选择器表达式匹配出来的元素，该方法依次尝试两种策略：
1. 使用JavaScript触发点击事件。
2. 如果第一种尝试失败，则使用原生QtWebKit事件。

例如：
```js
casper.start('http://google.fr/');

casper.thenEvaluate(function(term) {
    document.querySelector('input[name="q"]').setAttribute('value', term);
    document.querySelector('form[name="f"]').submit();
}, 'CasperJS');

casper.then(function() {
    // Click on 1st result link
    this.click('h3.r a');
});

casper.then(function() {
    // Click on 1st result link
    this.click('h3.r a',10,10);
});

casper.then(function() {
    // Click on 1st result link
    this.click('h3.r a',"50%","50%");
});


casper.then(function() {
    console.log('clicked ok, new location is ' + this.getCurrentUrl());
});

casper.run();
```

#### clickLabel( )
**调用方法**： clickLabel(String label\[, String tag\])

*0.6.1版本新增*

找到包含标签文本的第一个DOM元素，并确保元素节点名称是标签（可选）：
```js
// <a href="...">My link is beautiful</a>
casper.then(function() {
    this.clickLabel('My link is beautiful', 'a');
});

// <button type="submit">But my button is sexier</button>
casper.then(function() {
    this.clickLabel('But my button is sexier', 'button');
});
```

#### capture( )
**调用方法** : capture(String targetFilepath, \[Object clipRect, Object imgOptions\])

PhantomJS的WebPage＃render的代理方法，添加一个截屏参数，用于自动设置页面截屏设置，并在完成后将其还原：
```js
casper.start('http://www.google.fr/', function() {
    this.capture('google.png', {
        top: 100,
        left: 100,
        width: 500,
        height: 400
    });
});

casper.run();
```

*版本1.1新增*

imgOptions对象允许指定两个选项:
- `format`可以手动设置图像格式，避免依赖文件名。
- `quality`可以设置图像质量，数值从1到100。

示例：
```js
casper.start('http://foo', function() {
    this.capture('foo', undefined, {
        format: 'jpg',
        quality: 75
    });
});
```

#### captureBase64()
**调用方式**：captureBase64(String format\[, Mixed area\])

以给定的格式计算当前页面或页面内的区域的二进制图像捕获的Base64表示.

支持的图像格式有：bmp,jpg,jpeg,png,ppm,tiff,xbm,xpm。

`area`参数可以是以下几种类型：
- String：一个CSS3选择器字符串，比如：`div#plop form[name="form"] input[type="submit"]`。
- cilpRect: 一个cilpRect对象，比如：`{"top":0,"left":0,"width":320,"height":200}`
- Object: 一个选择器对象，比如：一个XPath选择器。

例子：
```js
casper.start('http://google.com', function() {
    // selector capture
    console.log(this.captureBase64('png', '#lga'));
    // clipRect capture
    console.log(this.captureBase64('png', {
        top: 0,
        left: 0,
        width: 320,
        height: 200
    }));
    // whole page capture
    console.log(this.captureBase64('png'));
});

casper.run();
```

#### captureSelector()
**调用方法**： captureSelector(String targetFile, String selector \[, Object imgOptions\])

捕获包含提供的选择器的页面区域并将其保存到`targetFile`：
```js
casper.start('http://www.weather.com/', function() {
    this.captureSelector('weather.png', '#LookingAhead');
});

casper.run();
```

*版本1.1新增*

`imgOptions`对象允许指定两个选项：
- `format`允许指定保存文件的格式，而不依赖于文件名。
- `quality`可以设置图像质量，数值从1到100。

#### clear( )
**调用方法**：clear( )

*版本0.6.5新增*
清除当前页面执行环境上下文，避免先前加载的DOM内容仍然活动。

它是在远程DOM环境中阻止JavaScript执行的一种方法：
```js
casper.start('http://www.google.fr/', function() {
    this.clear(); // 本页面的JavaScript将停止执行
});

casper.then(function() {
    // ...
});

casper.run();
```

#### clearCache()
**调用方法**：clearCache( )

*版本1.1.5新增*

用newPage()将新页面对象替换为当前页面，并使用clearMemoryCache()清除内存缓存。例子：
```js
casper.start('http://www.google.fr/', function() {
    this.clearCache(); // cleared the memory cache and replaced page object with newPage().
});

casper.then(function() {
    // ...
});

casper.run();
```

#### clearMemoryCache()
**调用方法**： clearMemoryCache()

*版本1.1.5新增*

使用引擎的`page.clearMemoryCache()`方法来清除内存缓存。例子：
```js
casper.start('http://www.google.fr/', function() {
    this.clearMemoryCache(); // cleared the memory cache.
});

casper.then(function() {
    // ...
});

casper.run();
```

#### debugHTML()
**调用方法**：debugHTML(\[String selector, Boolean outer\])

在控制台直接输出`getHTML()`的结果，它的参数与`getHTML()`相同。

#### debugPage()
**调用方法**：debugPage()

将当前页面的文本内容直接记录到标准输出，以进行调试：
```js
casper.start('http://www.google.fr/', function() {
    this.debugPage();
});

casper.run();
```

#### die( )
**调用方法**：die(String message\[, int status])

退出phantom并返回一条错误信息和一个状态码（可选）。
```js
casper.start('http://www.google.fr/', function() {
    this.die("Fail.", 1);
});

casper.run();
```

#### download( )
**调用方法**：download(String url, String target\[, String method, Object data])

将远程资源保存到本地。你还可以设置`method`指定http的传输方式，并通过data对象传递请求参数。
```js
casper.start('http://www.google.fr/', function() {
    var url = 'http://www.google.fr/intl/fr/about/corporate/company/';
    this.download(url, 'google_company.html');
});

casper.run(function() {
    this.echo('Done.').exit();
});
```

>##### 提示
如果你在下载文件时遇到了一些问题，把[web security](http://docs.casperjs.org/en/latest/faq.html#faq-web-security)关掉再试试。

#### each( )
**调用方法**：each(Array array, Function fn)
遍历一个给定的数组并对每一项执行一个回调函数。
```js
var links = [
    'http://google.com/',
    'http://yahoo.com/',
    'http://bing.com/'
];

casper.start().each(links, function(self, link) {
    self.thenOpen(link, function() {
        this.echo(this.getTitle());
    });
});

casper.run();
```

> ##### 提示
看一下具体是如何使用这个案例的[googlematch.js](https://github.com/casperjs/casperjs/blob/master/samples/googlematch.js)示例脚本。

#### eachThen( )
**调用方式**：eachThen(Array array, Function then)

*版本1.1新增*

迭代提供的数组项目，并向堆栈添加一个与当前数据相连的步骤。
```js
casper.start().eachThen([1, 2, 3], function(response) {
    this.echo(response.data);
}).run();
```

这里有一个打开一个url数组的例子：
```js
var casper = require('casper').create();
var urls = ['http://google.com/', 'http://yahoo.com/'];

casper.start().eachThen(urls, function(response) {
  this.thenOpen(response.data, function(response) {
    console.log('Opened', response.url);
  });
});

casper.run();
```

> ##### 提示
当前的数组项目会被存储在`respense.data`中。

#### echo( )
**调用方式**：echo(String message[, String style])

在标准输出流中输出字符，还可以给字符添加漂亮的颜色哦！（看[这里](http://docs.casperjs.org/en/latest/modules/colorizer.html#colorizer-module)了解更多。

```js
casper.start('http://www.google.fr/', function() {
    this.echo('Page title is: ' + this.evaluate(function() {
        return document.title;
    }), 'INFO'); // 会在控制台输出绿色的字符哦
});

casper.run();
```

#### evaluate( )
**调用方式**：evaluate(Function fn[, arg1[, arg2\[, …]]])
与 PhantomJS的WebPage#evaluate方法基本相同，即执行一段浏览器原生dom语句。
```js
casper.evaluate(function(username, password) {
    document.querySelector('#username').value = username;
    document.querySelector('#password').value = password;
    document.querySelector('#submit').click();
}, 'sheldon.cooper', 'b4z1ng4');
```

> ##### 提示
如果你想填充表单，最好还是使用`fill()`方法。

---
> #### 理解`evaluate( )`
这个方法背后的概念应该是我们开发CasperJS时遇到的最难理解的一个，你可以把这个方法当作CasperJS环境通往你打开页面的大门，每当你向`evaluate()`传递一个关闭命令时，你就相当于在打开页面的控制台中执行代码。
这是一个快速起草的图，大概解释了分离问题：
![img](http://docs.casperjs.org/en/latest/_images/evaluate-diagram.png)


#### evaluateOrDie()
**调用方式**：evaluateOrDie(Function fn\[, String message, int status\])

在当前页面检测某个dom表达式是否存在，如果返回的结果为true则执行die()函数。
```js
casper.start('http://foo.bar/home', function() {
    this.evaluateOrDie(function() {
        return /logged in/.match(document.title);
    }, 'not authenticated');
});

casper.run();
```

#### exit( )
**调用方式**：exit(\[int status])

使用状态代码（可选）退出PhantomJS。

你不能依赖这个方法立即退出你的脚本，因为这个函数是异步工作的，也就是说当你异步调用了这个方法后，你的脚本仍然在运行（而不是立即结束）。在[这里](https://github.com/casperjs/casperjs/issues/193)查看更多详情。

#### exists()
**调用方式**：exists(String selector)

检查dom中是否有与提供的选择器匹配的元素：
```js
casper.start('http://foo.bar/home', function() {
    if (this.exists('#my_super_id')) {
        this.echo('found #my_super_id', 'INFO');
    } else {
        this.echo('#my_super_id not found', 'ERROR');
    }
});

casper.run();
```

#### fetchText( )

**调用方式**：fetchText(String selector)

检索与给定选择器表达式匹配的文本内容。如果您提供的表达式匹配到多个元素，它们的文本内容将被连接：
```js
casper.start('http://google.com/search?q=foo', function() {
    this.echo(this.fetchText('h3'));
}).run();
```

#### forward()

**调用方式**：forward()

返回浏览器历史中当前页面的下一页：
```js
casper.start('http://foo.bar/1')
casper.thenOpen('http://foo.bar/2');
casper.thenOpen('http://foo.bar/3');
casper.back();    // http://foo.bar/2
casper.back();    // http://foo.bar/1
casper.forward(); // http://foo.bar/2
casper.run();
```

#### log( )

**调用方式**： log(String message\[, String level, String space])

在某个可选空间中输出可选级别的消息。可选的级别有：`debug`,`info`,`warning`,`error`。空间指的是你可以过滤log消息的某种命名空间。CasperJS默认在两个不同的空间中输出消息：`phantom`和`remote`，要区分PhantomJS环境中远程发生的情况，你可以这样写：
```js
casper.start('http://www.google.fr/', function() {
    this.log("I'm logging an error", "error");
});

casper.run();
```

#### fill()

**调用方式**：fill(String selector, Object values\[, Boolean submit])

填充文本域并决定是否要提交表单（可选），要填充的文本域是通过它们的name属性来辨别的。

*在版本1.1中改变*：如果你要使用CSS3和XPath表达式，请使用fillSelectors()和fillXPath()方法。

示例html代码：
```html
<form action="/contact" id="contact-form" enctype="multipart/form-data">
    <input type="text" name="subject"/>
    <textearea name="content"></textearea>
    <input type="radio" name="civility" value="Mr"/> Mr
    <input type="radio" name="civility" value="Mrs"/> Mrs
    <input type="text" name="name"/>
    <input type="email" name="email"/>
    <input type="file" name="attachment"/>
    <input type="checkbox" name="cc"/> Receive a copy
    <input type="submit"/>
</form>
```

填充并提交表单：
```js
casper.start('http://some.tld/contact.form', function() {
    this.fill('form#contact-form', {
        'subject':    'I am watching you',
        'content':    'So be careful.',
        'civility':   'Mr',
        'name':       'Chuck Norris',
        'email':      'chuck@norris.com',
        'cc':         true,
        'attachment': '/Users/chuck/roundhousekick.doc'
    }, true);
});

casper.then(function() {
    this.evaluateOrDie(function() {
        return /message sent/.test(document.body.innerText);
    }, 'sending message failed');
});

casper.run(function() {
    this.echo('message sent').exit();
});
```

fill()方法支持支持填充单选框，用法与填充文本域一样，对于多选框，你可以使用与多选值对应的数组：
```html
<form action="/contact" id="contact-form" enctype="multipart/form-data">
    <select multiple name="category">
    <option value=​"0">Friends​</option>​
    <option value=​"1">​Family​</option>​
    <option value=​"2">​Acquitances​</option>​
    <option value=​"3">​Colleagues</option>​
    </select>
</form>
```
填充多选域的脚本：
```js
casper.then(function() {
   this.fill('form#contact-form', {
       'categories': ['0', '1'] // Friends and Family
   });
});
```

> ##### 警告
`fill()`方法填充文本域**并不支持XPath选择器**，PhantomJS原生`uploadFile()`方法只支持CSS3选择器，加强了这个限制。

#### fillSelectors()
**调用方式**：fillSelectors(String selector, Object values\[, Boolean submit])

*版本1.1新增*
这个方法可以填充表单并提交表单（可选），本方法配适css3的选择器：
```js
casper.start('http://some.tld/contact.form', function() {
    this.fillSelectors('form#contact-form', {
        'input[name="subject"]':    'I am watching you',
        'input[name="content"]':    'So be careful.',
        'input[name="civility"]':   'Mr',
        'input[name="name"]':       'Chuck Norris',
        'input[name="email"]':      'chuck@norris.com',
        'input[name="cc"]':         true,
        'input[name="attachment"]': '/Users/chuck/roundhousekick.doc'
    }, true);
});
```

#### fillLabels( )
**调用方式**：fillLabels(String selector, Object values\[, Boolean submit])

*版本1.1新增*

根据`label`标签提供的字段名来填写表单：
```js
casper.start('http://some.tld/contact.form', function() {
    this.fillLabels('form#contact-form', {
        Email:         'chuck@norris.com',
        Password:      'chuck',
        Content:       'Am watching thou',
        Check:         true,
        No:            true,
        Topic:         'bar',
        Multitopic:    ['bar', 'car'],
        File:          fpath,
        "1":           true,
        "3":           true,
        Strange:       "very"
    }, true);
});
```

#### fillXPath( )
**调用方式**： fillXPath(String selector, Object values\[, Boolean submit])

*版本1.1新增*

使用XPath选择器选择字段填写表单并（可选）提交表单：
```js
casper.start('http://some.tld/contact.form', function() {
    this.fillXPath('form#contact-form', {
        '//input[@name="subject"]':    'I am watching you',
        '//input[@name="content"]':    'So be careful.',
        '//input[@name="civility"]':   'Mr',
        '//input[@name="name"]':       'Chuck Norris',
        '//input[@name="email"]':      'chuck@norris.com',
        '//input[@name="cc"]':         true,
    }, true);
});
```

> 警告
使用XPath选择器目前还不能填充文件域，是因为PhantomJS原生函数`uploadFile( )`不支持XPath选择器。

#### getCurrentUrl( )
**调用方式**：getCurrentUrl()

检索当前页面的URL，请注意，url将被url解码：
```js
casper.start('http://www.google.fr/', function() {
    this.echo(this.getCurrentUrl()); // "http://www.google.fr/"
});

casper.run();
```

#### getElementAttribute( )
**调用方式**：getElementAttribute(String selector, String attribute)

*版本1.0新增*

检索匹配你提供的选择器的元素的属性值：
```js
var casper = require('casper').create();

casper.start('http://www.google.fr/', function() {
    require('utils').dump(this.getElementsAttribute('div[title="Google"]', 'title')); // "['Google']"
});

casper.run();
```

#### getElementBounds()
**调用方式**： getElementBounds(String selector, Boolean page)

检索与提供的选择器匹配的DOM元素的边界。如果页面中含有frame/iframe元素，请将`page`参数设置为`true`.

这个方法会返回一个拥有4个属性的对象，分别是：`top`,`left`,`width`,`height`，当元素不存在时返回`null`：
```js
var casper = require('casper').create();

casper.start('http://www.google.fr/', function() {
    require('utils').dump(this.getElementBounds('div[title="Google"]'));
});

casper.run();
```
你会得到像这样的输出：
```js
{
    "height": 95,
    "left": 352,
    "top": 16,
    "width": 275
}
```

#### getElementsBounds()
**调用方式**：getElementsBounds(String selector)

*版本1.0新增*

返回匹配到的所有元素的位置信息。

这个方法会返回一个对象数组，对象结构与`getElementBounds()`相同。

#### getElementInfo( )
**调用方式**：getElementInfo(String selector)

*版本1.0新增*

获取选择器匹配到的第一个元素的信息：
```js
casper.start('http://google.fr/', function() {
    require('utils').dump(this.getElementInfo('#hplogo'));
});
```

你会得到这样的结果：
```js
{
    "attributes": {
        "align": "left",
        "dir": "ltr",
        "id": "hplogo",
        "onload": "window.lol&&lol()",
        "style": "height:110px;width:276px;background:url(/images/srpr/logo1w.png) no-repeat",
        "title": "Google"
    },
    "height": 110,
    "html": "<div nowrap=\"nowrap\" style=\"color:#777;font-size:16px;font-weight:bold;position:relative;left:214px;top:70px\">France</div>",
    "nodeName": "div",
    "tag": "<div dir=\"ltr\" title=\"Google\" align=\"left\" id=\"hplogo\" onload=\"window.lol&amp;&amp;lol()\" style=\"height:110px;width:276px;background:url(/images/srpr/logo1w.png) no-repeat\"><div nowrap=\"nowrap\" style=\"color:#777;font-size:16px;font-weight:bold;position:relative;left:214px;top:70px\">France</div></div>",
    "text": "France\n",
    "visible": true,
    "width": 276,
    "x": 62,
    "y": 76
}
```

#### getElementsInfo()
**调用方式**：getElementsInfo(String selector)

*版本1.1新增*

获取选择器匹配到的所有元素的信息：
```js
casper.start('http://google.fr/', function() {
    require('utils').dump(this.getElementsInfo('#hplogo'));
});
```

你会得到类似这样的结果：
```js
[
    {
        "attributes": {
            "align": "left",
            "dir": "ltr",
            "id": "hplogo",
            "onload": "window.lol&&lol()",
            "style": "height:110px;width:276px;background:url(/images/srpr/logo1w.png) no-repeat",
            "title": "Google"
        },
        "height": 110,
        "html": "<div nowrap=\"nowrap\" style=\"color:#777;font-size:16px;font-weight:bold;position:relative;left:214px;top:70px\">France</div>",
        "nodeName": "div",
        "tag": "<div dir=\"ltr\" title=\"Google\" align=\"left\" id=\"hplogo\" onload=\"window.lol&amp;&amp;lol()\" style=\"height:110px;width:276px;background:url(/images/srpr/logo1w.png) no-repeat\"><div nowrap=\"nowrap\" style=\"color:#777;font-size:16px;font-weight:bold;position:relative;left:214px;top:70px\">France</div></div>",
        "text": "France\n",
        "visible": true,
        "width": 276,
        "x": 62,
        "y": 76
    }
]
```

> ##### 提示
这个方法返回的并不是元素集，而仅仅是一个包含对象属性的简单数组。这是因为CasperJS环境并没有直接取得页面元素的权限。

#### getFormValues()
**调用方式**：getFormValues(String selector)

*版本1.1新增*

获取一个表单中所有填充域的值：
```js
casper.start('http://www.google.fr/', function() {
    this.fill('form', {q: 'plop'}, false);
    this.echo(this.getFormValues('form').q); // 'plop'
});

casper.run();
```

#### getGlobal()

**调用方式**：getGlobal(String name)

获取页面全局对象的值，一般来说，`getGlobal('foo')`可以获取window.foo对象的值。
```js
casper.start('http://www.google.fr/', function() {
    this.echo(this.getGlobal('innerWidth')); // 1024
});

casper.run();
```

#### getHTML()
**调用方式**：getHTML(\[String selector, Boolean outer])

*版本1.0新增*

返回页面的html代码，默认输出整个页面的HTML内容：
```js
casper.start('http://www.google.fr/', function() {
    this.echo(this.getHTML());
});

casper.run();
```

getHTML()方法还可以指定获取HTML代码还是内容，看例子：
```html
<html>
    <body>
        <h1 id="foobar">Plop</h1>
    </body>
</html>
```
只获取匹配到标签中的文本内容，你可以：
```js
casper.start('http://www.site.tld/', function() {
    this.echo(this.getHTML('h1#foobar')); // => 'Plop'
});
```
如果要获取所有HTML（含标签）内容：
```js
casper.start('http://www.site.tld/', function() {
    this.echo(this.getHTML('h1#foobar', true)); // => '<h1 id="foobar">Plop</h1>'
});
```

#### getPageContent( )
**调用方法**：getPageContent()

*版本1.0新增*

返回当前页面内容，这个方法主要用于处理非HTML内容的页面：
```js
var casper = require('casper').create();

casper.start().then(function() {
    this.open('http://search.twitter.com/search.json?q=casperjs', {
        method: 'get',
        headers: {
            'Accept': 'application/json'
        }
    });
});

casper.run(function() {
    require('utils').dump(JSON.parse(this.getPageContent()));
    this.exit();
});
```

#### getTitle()
**调用方法**：getTitle()
返回当前页面的标题：
```js
casper.start('http://www.google.fr/', function() {
    this.echo(this.getTitle()); // "Google"
});

casper.run();
```

#### mouseEvent()
**调用方法**： mouseEvent(String type, String selector, \[Number|String X, Number|String Y])

*版本0.6.9新增*

在第一个匹配到的元素上触发鼠标事件。

支持的事件类型有:`mouseup`,`mousedown`,`click`,`dblclick`,`mousemove`,`mouseover`,
`mouseout`,如果你的phantomJS版本大于1.9.8，还支持`mouseenter`,`mouseleave`和`contextmenu`事件。

> ##### 警告
支持的事件类型取决于你使用的引擎，老版本的引擎只提供部分事件的支持，所以，为了提供最好的支持，你最好使用最新版本的引擎：
```js
casper.start('http://www.google.fr/', function() {
    this.mouseEvent('click', 'h2 a', "20%", "50%");
});

casper.run();
```

#### newPage()
**调用方法**： newPage()

*版本1.1新增*

**只有1.1.0版本后的版本才支持这个函数。**

创建一个新的页面：
```js
casper.start('http://google.com', function() {
    // ...
});

casper.then(function() {
    casper.page = casper.newPage();
    casper.open('http://yahoo.com').then( function() {
        // ....
    });
});

casper.run();
```

#### open()
**调用方法**：  open(String location, Object Settings)

执行打开给定位置的HTTP请求。您可以伪造GET，POST，PUT，DELETE和HEAD请求。

GET请求的例子
```js
casper.start();

casper.open('http://www.google.com/').then(function() {
    this.echo('GOT it.');
});

casper.run();
```

POST请求的例子：
```js
casper.start();

casper.open('http://some.testserver.com/post.php', {
    method: 'post',
    data:   {
        'title': 'Plop',
        'body':  'Wow.'
    }
});

casper.then(function() {
    this.echo('POSTED it.');
});

casper.run();
```

传递嵌套的参数数组：
```js
casper.start();

casper.open('http://some.testserver.com/post.php', {
    method: 'post',
    data:   {
        'title': 'Plop',
        'body':  'Wow.'
    }
});

casper.then(function() {
    this.echo('POSTED it.');
});

casper.run();
```

*版本1.0新增*

以utf-8编码方式发送数据：
```js
casper.open('http://some.testserver.com/post.php', {
       method: 'post',
       headers: {
           'Content-Type': 'application/json; charset=utf-8'
       },
       encoding: 'utf8', // not enforced by default
       data: {
            'table_flip': '(╯°□°）╯︵ ┻━┻ ',
       }
});
```

*版本1.0新增*

您还可以在执行传出请求时设置要发送的自定义请求标头，比如：
```js
casper.open('http://some.testserver.com/post.php', {
    method: 'post',
    data:   {
        'title': 'Plop',
        'body':  'Wow.'
    },
    headers: {
        'Accept-Language': 'fr,fr-fr;q=0.8,en-us;q=0.5,en;q=0.3'
    }
});
```

#### reload( )
**调用方式**： reload(\[Function then])

*版本1.0新增*

重新加载当前页面：
```js
casper.start('http://google.com', function() {
    this.echo("loaded");
    this.reload(function() {
        this.echo("loaded again");
    });
});

casper.run();
```

#### repeat()
**调用方式**： repeat(int times, Function then)

将一个行为重复执行指定的次数。
```js
casper.start().repeat(3, function() {
    this.echo("Badger");
});

casper.run();
```

#### resourceExists()
**调用方式**：resourceExists(String|Function|RegExp test)

检查某个资源是否被加载了，这个方法的参数可以是function，string和RegExp实例。
```js
casper.start('http://www.google.com/', function() {
    if (this.resourceExists('logo3w.png')) {
        this.echo('Google logo loaded');
    } else {
        this.echo('Google logo not loaded', 'ERROR');
    }
});

casper.run();
```

> ##### 提示
如果你想等到资源加载完毕，可以使用`waitForResource()`函数。

#### run()
**调用方式**：run(fn onComplete\[, int time])

运行整套步骤，并且可以在完成后执行回调。显然，为了运行Casper导航套件，调用此方法是必需的。

这样写的话CasperJS套件是不会运行的哦：
```js
casper.start('http://foo.bar/home', function() {
    // ...
});

// hey, it's missing .run() here!
```

这样CasperJS套件才会运行：
```js
casper.start('http://foo.bar/home', function() {
    // ...
});

casper.run();
```

`Casper.run()`方法同样接受一个`onComplete`的回调方法，可以将其视为在执行所有其他步骤时执行的自定义最终步骤，只是在定义了这个函数后，要记得使用`exit()`方法退出Casper。
```js
casper.start('http://foo.bar/home', function() {
    // ...
});

casper.then(function() {
    // ...
});

casper.run(function() {
    this.echo('So the whole suite ended.');
    this.exit(); // <--- don't forget me!
});
```
将回调绑定到complete.error将在onComplete回调失败时触发。

#### scrollTo()
**调用方式**：scrollTo(Number x, Number y)

*版本1.1-beta3新增*

滚动页面到指定的坐标(x和y坐标)。
```js
casper.start('http://foo.bar/home', function() {
    this.scrollTo(500, 300);
});
```

> ##### 提示
此操作是同步的。

#### scrollToBottom()
**调用方式**：scrollToBottom()

*版本1.1-beta3新增*

滚动页面到最底部。
```js
casper.start('http://foo.bar/home', function() {
    this.scrollToBottom();
});
```

> ##### 提示
此操作是同步的。

#### sendKeys()
**调用方式**：sendKeys(Selector selector, String keys\[, Object options])

*版本1.0新增*

将本地键盘事件发送到与提供的选择器匹配的元素：
```js
casper.then(function() {
    this.sendKeys('form.contact input#name', 'Duke');
    this.sendKeys('form.contact textarea#message', "Damn, I'm looking good.");
    this.click('form.contact input[type="submit"]');
});
```

*版本1.1新增*

目前`sendKeys()`方法支持的元素不仅包括`<input>`和`<textarea>`元素，还包括所有
`contenteditable`属性为`true`的元素。

###### 自定义属性
- (Boolean) reset:

  *版本1.1-beta3新增*

  当reset的值为true时，该方法会首先将文本域清空，当值为false时，该方法仅仅会将字符串添加在文本域已有的文字之后。


  - (Boolean) keepFocus:

  默认情况下，`sendKeys()`会清除文本域的自动聚焦，通常意味着关闭了自动完成的部件。如果你想保留聚焦，就使用`keepFocus `属性。例如，在jQuery-UI中，你可以选择自动补全功能中的提示输入：
  ```js
  casper.then(function() {
    this.sendKeys('form.contact input#name', 'action', {keepFocus: true});
    this.click('form.contact ul.ui-autocomplete li.ui-menu-item:first-  child a');
});
```


- (String) modifiers:

sendKeys（）接受一个修饰符选项来支持键修饰符。它的选项是一个表示要使用的修饰符的组合的字符串，由+字符分隔：
```js
casper.then(function() {
    this.sendKeys('document', 's', {modifiers: 'ctrl+alt+shift'});
});
```
可用的修饰符有：
- ctrl
- alt
- shift
- meta
- keypad


#### setHttpAuth()
**调用方式**：setHttpAuth(String username, String password)

为基于HTTP的身份验证系统设置HTTP_AUTH_USER和HTTP_AUTH_PW值：
```js
casper.start();

casper.setHttpAuth('sheldon.cooper', 'b4z1ng4');

casper.thenOpen('http://password-protected.domain.tld/', function() {
    this.echo("I'm in. Bazinga.");
})
casper.run();
```

当然你可以直接传递url中的auth字符串来打开：
```js
var url = 'http://sheldon.cooper:b4z1ng4@password-protected.domain.tld/';

casper.start(url, function() {
    this.echo("I'm in. Bazinga.");
})

casper.run();
```

#### setMaxListeners()
**调用方式**：setMaxListeners(Integer maxListeners)

设置可以为每种类型的监听器添加的监听的最大数量：
```js
casper.setMaxListeners(12);
```

> #### 提示
您的casper脚本中的监听器注册不正确可能会导致一条警告消息，指示已检测到可能的EventEmitter泄漏。确保您以要求的方式添加监听器。

如果您需要一个将被所有脚本处理的监听器，那么请确保它只被注册一次。例如，如果您需要为每个测试套件添加一个监听器，请确保在setUp期间添加监听器，并在tearDown期间删除该监听器。有关setUp和tearDown结构，请参阅[Tester＃begin()](http://docs.casperjs.org/en/latest/modules/tester.html#tester-begin-configuration)。


> #### 警告
我们不建议更改最大监听器的数量，只有当你添加的监听事件超过最大限制时，才去增加它的最大数量，增加此限制会增加所有监听器类型，并且可能导致事件未发现的事件泄漏。如果您必须增加此限制，请以小增量增加该限制。


#### start()
**调用方式**： start(String url\[, Function then])

配置并启动Casper，然后打开提供的URL，并执行`step`数组提供的步骤(可选)：
```js
casper.start('http://google.fr/', function() {
    this.echo("I'm loaded.");
});

casper.run();
```

另一种书写方法：
```js
casper.start('http://google.fr/');

casper.then(function() {
    this.echo("I'm loaded.");
});

casper.run();
```

还可以这样写：
```js
casper.start('http://google.fr/');

casper.then(function() {
    casper.echo("I'm loaded.");
});

casper.run();
```
选择哪种书写方式全凭你的喜好。

> ##### 提示
您必须调用start（）方法才能添加导航步骤并运行该套件。如果你不这样做，你会收到一条错误消息提示你这样做。

#### status()
**调用方式**： status(Boolean asString)

*版本1.0新增*

返回当前实例的状态：
```js
casper.start('http://google.fr/', function() {
    this.echo(this.status(true));
});

casper.run();
```

#### switchToFrame()
**调用方式**： switchToFrame(String|Number frameInfo)

*版本1.1.5新增*

将主页切换到具有与传递参数相匹配的名称或帧索引号的frame中。将本地脚本，远程脚本和客户端工具注入此frame。

#### switchToMainFrame()
**调用方式**： switchToMainFrame()

*版本1.1.5新增*

将主页面切换到当前活动页面的父frame。

#### switchToParentFrame()
**调用方式**： switchToParentFrame()

*版本1.1.5新增*

将主页面切换到主框架。

#### then()
**调用方式**： then(Function then)

这个方法是将一个新步骤添加到栈的标准方法，只需要一个简单的函数：
```js
casper.start('http://google.fr/');

casper.then(function() {
    this.echo("I'm in your google.");
});

casper.then(function() {
    this.echo('Now, let me write something');
});

casper.then(function() {
    this.echo('Oh well.');
});

casper.run();
```

你想添加多少步骤都可以。注意目前的`casper`实例将会自动绑定`this`指针。

想要运行你所有定义的步骤，调用`run()`方法，然后结果就会出现了。

> ##### 提示
你需要先`start()`一个Casper实例之后才可以使用`then()`方法。



> #### 访问当前的HTTP响应
*版本1.0新增*

你可以使用回调函数的第一个参数来访问当前的HTTP响应：
```js
casper.start('http://www.google.fr/', function(response) {
    require('utils').dump(response);
});
```

将显示的结果：
```js
$ casperjs dump-headers.js
{
    "contentType": "text/html; charset=UTF-8",
    "headers": [
        {
            "name": "Date",
            "value": "Thu, 18 Oct 2012 08:17:29 GMT"
        },
        {
            "name": "Expires",
            "value": "-1"
        },
        // ... lots of other headers
    ],
    "id": 1,
    "redirectURL": null,
    "stage": "end",
    "status": 200,
    "statusText": "OK",
    "time": "2012-10-18T08:17:37.068Z",
    "url": "http://www.google.fr/"
}
```

你也可以访问某一个具体的头信息：
```js
casper.start('http://www.google.fr/', function(response) {
    this.echo(response.headers.get('Date'));
});
```

结果：
```
$ casperjs dump-headers.js
Thu, 18 Oct 2012 08:26:34 GMT
```

> ##### 警告
`then()`函数会在以下两种情况后被执行：
1. 当上一个步骤被执行之后。
2. 当上一个HTTP请求被处理并加载页面后。

但是要知道，我们对于‘页面加载’的时间点没有一个明确的定义，是DOMReady事件被触发之后吗？还是'当所有的请求都完成了'？，还是‘所有的应用逻辑都已完成’？还是’所有的元素都渲染完成了‘？答案永远取决于上下文。所以我们强烈建议你使用'waitFor()'家族的方法来明确控制逻辑是你期望的那样。

通常的做法是使用` waitForSelector()`：
```js
casper.start('http://my.website.com/');

casper.waitForSelector("#plop", function() {
    this.echo("I'm sure #plop is available in the DOM");
});

casper.run();
```


#### thenBypass()
**调用方式**： thenBypass(Number nb)

*版本1.1新增*

跳过指定数量的步骤：
```js
casper.start('http://foo.bar/');
casper.thenBypass(2);
casper.then(function() {
    // This test won't be executed
});
casper.then(function() {
    // Nor this one
});
casper.then(function() {
    // While this one will
});
casper.run();
```

#### thenBypassIf()
**调用方式**：thenBypassIf(Mixed condition, Number nb)

*版本1.1新增*
当参数为true或回调函数的返回值为true时，跳过指定数量的步骤：
```js
var universe = {
    answer: 42
};
casper.start('http://foo.bar/');
casper.thenBypassIf(function() {
    return universe && universe.answer === 42;
}, 2);
casper.then(function() {
    // This step won't be executed as universe.answer is 42
});
casper.then(function() {
    // Nor this one
});
casper.then(function() {
    // While this one will
});
casper.run();
```

#### thenBypassUnless()
**调用方式**：thenBypassIf(Mixed condition, Number nb)

*版本1.1新增*

 thenBypassIf()的反函数。

 #### thenClick()
 **调用方式**：thenClick(String selector\[, Function then])

点击一个选择器指定的元素并在点击后执行回调函数（可选）：
```js
// Click the first link in the casperJS page
casper.start('http://casperjs.org/').thenClick('a', function() {
    this.echo("I clicked on first link found, the page is now loaded.");
});

casper.run();
```

这个方法可以看作是`then()`和`cilck()`方法的结合。

#### thenClick()
**调用方式**：thenEvaluate(Function fn[, arg1[, arg2[, …]]])

在当前检索的页面DOM中执行代码评估：
```js
// Querying for "Chuck Norris" on Google
casper.start('http://google.fr/').thenEvaluate(function(term) {
    document.querySelector('input[name="q"]').setAttribute('value', term);
    document.querySelector('form[name="f"]').submit();
}, 'Chuck Norris');

casper.run()
```

这个方法可以看作是`then()`和`evaluate()`方法的结合。

#### thenOpen()
**调用方式**：thenOpen(String location\[, mixed options])

打开一个新页面，并在之后执行一些步骤（可选）：
```js
casper.start('http://google.fr/').then(function() {
    this.echo("I'm in your google.");
});

casper.thenOpen('http://yahoo.fr/', function() {
    this.echo("Now I'm in your yahoo.")
});

casper.run();
```

*版本1.0新增*

你还可以在第二个参数中设置具体的访问选项：
```js
casper.start().thenOpen('http://url.to/some/uri', {
    method: "post",
    data: {
        username: 'chuck',
        password: 'n0rr15'
    }
}, function() {
    this.echo("POST request has been sent.")
});

casper.run();
```

#### thenOpenAndEvaluate()
**调用方式**：thenOpenAndEvaluate(String location[, Function then[, arg1[, arg2[, …]]])

一个打开新页面并在远程dom环境中执行代码评估的简短版本：
```js
casper.start('http://google.fr/').then(function() {
    this.echo("I'm in your google.");
});

casper.thenOpenAndEvaluate('http://yahoo.fr/', function() {
    var f = document.querySelector('form');
    f.querySelector('input[name=q]').value = 'chuck norris';
    f.submit();
});

casper.run(function() {
    this.debugPage();
    this.exit();
});
```

#### toString()
**调用方式**：toString()

*版本1.0新增*

返回一个Casper实例的字符串表示：
```js
casper.start('http://google.fr/', function() {
    this.echo(this); // [object Casper], currently at http://google.fr/
});

casper.run();
```
#### unwait()
**调用方式**： unwait()

*版本1.1新增*

中止所有当前的等待进程。

#### userAgent()
**调用方式**： userAgent(String agent)

在发送请求时在请求头中设置userAgent字符串：
```js
casper.start();

casper.userAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X)');

casper.thenOpen('http://google.com/', function() {
    this.echo("I'm a Mac.");
    this.userAgent('Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)');
});

casper.thenOpen('http://google.com/', function() {
    this.echo("I'm a PC.");
});

casper.run();
```

#### viewport()
**调用方式**： viewport(Number width, Number height\[, Function then])

改变当前视口的尺寸：
```
casper.viewport(1024, 768);
```
为了确保页面回流发生，你必须异步使用这个函数：
```js
casper.viewport(1024, 768).then(function() {
    // new view port is now effective
});
```

*版本1.1新增*

在1.1版本之后你可以直接将`then`步骤函数传入`viewport()`中：
```js
casper.viewport(1024, 768, function() {
    // new view port is effective
});
```

> ##### 提示
 PhantomJS 的默认视口大小为400*300，CasperJS无法重写它的默认值。

 #### visible()
 **调用方式**： visible(String selector)

检测选择器指定的元素在页面上是否可见：
```js
casper.start('http://google.com/', function() {
    if (this.visible('#hplogo')) {
        this.echo("I can see the logo");
    } else {
        this.echo("I can't see the logo");
    }
});
```

#### wait()
**调用方式**： wait(Number timeout\[, Function then])

使某一步骤等待指定是的时间后执行指定的回调函数（可选）：
```js
casper.start('http://yoursite.tld/', function() {
    this.wait(1000, function() {
        this.echo("I've waited for a second.");
    });
});

casper.run();
```

你也可以这样写：
```js
casper.start('http://yoursite.tld/');

casper.wait(1000, function() {
    this.echo("I've waited for a second.");
});

casper.run();
```

#### waitFor()
**调用方式**： waitFor(Function testFx\[, Function then, Function onTimeout, Number timeout, Object details])

等待在函数返回true之后执行指定函数。

你还可以使用onTimeout参数设置超时回调，并使用timeout设置超时时间（以毫秒为单位）。默认超时时间为5000毫秒：
```js
casper.start('http://yoursite.tld/');

casper.waitFor(function check() {
    return this.evaluate(function() {
        return document.querySelectorAll('ul.your-list li').length > 2;
    });
}, function then() {
    this.captureSelector('yoursitelist.png', 'ul.your-list');
});

casper.run();
```

使用onTimeout的例子：
```js
casper.start('http://yoursite.tld/');

casper.waitFor(function check() {
    return this.evaluate(function() {
        return document.querySelectorAll('ul.your-list li').length > 2;
    });
}, function then() {    // step to execute when check() is ok
    this.captureSelector('yoursitelist.png', 'ul.your-list');
}, function timeout() { // step to execute if check has failed
    this.echo("I can't haz my screenshot.").exit();
});

casper.run();
```

当timeout事件被触发时，包含的信息集的details属性将会被传递到` waitFor.timeout`事件中，这可以用于提供更好的错误消息或有条件地忽略一些超时事件。

> ##### 提示
所有的`waitFor`方法都不是可链接的，不过你可以把它们包裹在`casper.then`方法中来达成这个功能。

*版本1.1.5新增*

从1.1.5开始，如果check函数仍然为false，则在超时后最后一次运行check函数。

#### waitForAlert()
**调用方式**： waitForAlert(Function then\[, Function onTimeout, Number timeout])

*版本1.1-beta4新增*

等待JavaScript alert事件被触发，你可以在回调函数中的`response.data`参数中获得alert的内容。
```js
casper.waitForAlert(function(response) {
    this.echo("Alert received: " + response.data);
});
```

#### waitForExec()
**调用方式**：  waitForExec(command, parameters\[, Function then, Function onTimeout, timeout])

*版本1.1.5新增*

等待直到command运行并退出。command, parameters, pid, stdout, stderr, elapsedTime和exitCode将会包含在response.data属性中。command必须为一个字符串，parameters必须为一个数组，command可以为一个可执行的字符串或一个可执行的字符串及其其由空格分隔的参数，如果命令是伪造的或不是字符串，则使用系统shell（环境变量SHELL或ComSpec）。由空格分隔的参数与要发送到可执行文件的parameters数组相连接。如果参数是伪造的或不是数组，则使用空数组。timeout可以是一个数字或两个数字的数组，第一个是wait*系列函数的超时，第二个是超时是TERM和KILL信号之间的超时。如果没有声明，它假定第一个元素的值相同或者等于wait家族函数的默认超时值：
```js
// merge captured PDFs with default system shell (bash on Linux) calling /usr/bin/gs, and runs a small script to remove files
casper.waitForExec(null, ['-c','{ /usr/bin/gs -dPDFSETTINGS=/ebook -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=/my_merged_captures.pdf  /my_captures*.pdf && /bin/rm /my_captures*.pdf; } || { /bin/rm /my_merged_captures.pdf && exit 1; }'],
    function(response) {
        this.echo("Program finished by itself:" + JSON.stringify(response.data));
    }, function(timeout, response) {
        this.echo("Program finished by casper:" + JSON.stringify(response.data));
});

 // merge captured PDFs with bash calling /usr/bin/gs, and runs a small script to remove files
casper.waitForExec('/bin/bash -c', ['{ /usr/bin/gs -dPDFSETTINGS=/ebook -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=/my_merged_captures.pdf  /my_captures*.pdf && /bin/rm /my_captures*.pdf; } || { /bin/rm /my_merged_captures.pdf && exit 1; }'],
    function(response) {
        this.echo("Program finished by itself:" + JSON.stringify(response.data));
    }, function(timeout, response) {
        this.echo("Program finished by casper:" + JSON.stringify(response.data));
});


// merge captured PDFs calling /usr/bin/gs
casper.waitForExec('/usr/bin/gs',['-dPDFSETTINGS=/ebook','-dBATCH','-dNOPAUSE','-q','-sDEVICE=pdfwrite','-sOutputFile=/my_merged_captures_pdfs.pdf','/my_captures_1.pdf','/my_captures_2.pdf','/my_captures_3.pdf'],
    function(response) {
        this.echo("Program finished by itself:" + JSON.stringify(response.data));
    }, function(timeout, response) {
        this.echo("Program finished by casper:" + JSON.stringify(response.data));
});

// merge captured PDFs calling /usr/bin/gs
casper.waitForExec('/usr/bin/gs -dPDFSETTINGS=/ebook -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=/my_merged_captures_pdfs.pdf /my_captures_1.pdf /my_captures_2.pdf /my_captures_3.pdf', null,
    function(response) {
        this.echo("Program finished by itself:" + JSON.stringify(response.data));
    }, function(timeout, response) {
        this.echo("Program finished by casper:" + JSON.stringify(response.data));
});
```

> ##### 提示
waitForExec（）仅在超时时终止被调用的程序，如果被调用的程序调用其他进程，则waitForExec（）超时时该进程不会被杀死。

#### waitForPopup()
**调用方式**：  waitForPopup(String|RegExp|Object urlPattern\[, Function then, Function onTimeout, Number timeout])

*版本1.0新增*

等待一个与提供的模式匹配的弹窗打开。

当前加载的弹出窗口在Casper.popups数组类属性中可用：
```js
casper.start('http://foo.bar/').then(function() {
    this.test.assertTitle('Main page title');
    this.clickLabel('Open me a popup');
});

// this will wait for the popup to be opened and loaded
casper.waitForPopup(/popup\.html$/, function() {
    this.test.assertEquals(this.popups.length, 1);
});

// this will wait for the first popup to be opened and loaded
casper.waitForPopup(0, function() {
    this.test.assertEquals(this.popups.length, 1);
});

// this will wait for the popup's named to be opened and loaded
casper.waitForPopup({windowName: "mainPopup"}, function() {
    this.test.assertEquals(this.popups.length, 1);
});

// this will wait for the popup's title to be opened and loaded
casper.waitForPopup({title: "Popup Title"}, function() {
    this.test.assertEquals(this.popups.length, 1);
});

// this will wait for the popup's url to be opened and loaded
casper.waitForPopup({url: 'http://foo.bar/'}, function() {
    this.test.assertEquals(this.popups.length, 1);
});

// this will set the popup DOM as the main active one only for time the
// step closure being executed
casper.withPopup(/popup\.html$/, function() {
    this.test.assertTitle('Popup title');
});

// next step will automatically revert the current page to the initial one
casper.then(function() {
    this.test.assertTitle('Main page title');
});
```

#### waitForResource()
**调用方式**： waitForResource(String|Function|RegExp testFx\[, Function then, Function onTimeout, Number timeout])

等待由`testFx`指定的资源加载完毕并准备好进行下一步。

`testFx`参数可以是一个字符串，一个函数或是一个正则表达式实例：
```js
casper.waitForResource("foobar.png", function() {
    this.echo('foobar.png has been loaded.');
});
```
使用正则表达式：
```js
casper.waitForResource(/foo(bar|baz)\.png$/, function() {
    this.echo('foobar.png or foobaz.png has been loaded.');
});
```
使用函数：
```js
casper.waitForResource(function testResource(resource) {
    return resource.url.indexOf("https") === 0;
}, function onReceived() {
    this.echo('a secure resource has been loaded.');
});
```

#### waitForUrl()
**调用方式**：  waitForUrl(String|RegExp url\[, Function then, Function onTimeout, Number timeout])

*版本1.1新增*

等待直到当前页面的url符合提供的模式（可以是字符串或正则表达式）：
```js
casper.start('http://foo/').waitForUrl(/login\.html$/, function() {
    this.echo('redirected to login.html');
});

casper.run();
```

#### waitForSelector()
**调用方式**：  waitForSelector(String selector\[, Function then, Function onTimeout, Number timeout])

等待与提供的选择器匹配的元素存在并执行下一步骤：
```js
casper.start('https://twitter.com/#!/n1k0');

casper.waitForSelector('.tweet-row', function() {
    this.captureSelector('twitter.png', 'html');
});

casper.run();
```

#### waitWhileSelector()
**调用方式**： waitWhileSelector(String selector\[, Function then, Function onTimeout, Number timeout])

在执行下一步骤之前等待与提供的选择器匹配的元素的内容改变：
```js
casper.start('http://foo.bar/');

casper.waitForSelectorTextChange('.selector', function() {
    this.echo('The text on .selector has been changed.');
});

casper.run();
```

#### waitForText()
**调用方式**： waitForText(String text\[, Function then, Function onTimeout, Number timeout])

*版本1.0新增*

等待直到指定的文本在当前页面出现：
```js
casper.start('http://why.univer.se/').waitForText("42", function() {
    this.echo('Found the answer.');
});

casper.run();
```

#### waitUntilVisible()
**调用方式**： waitUntilVisible(String selector\[, Function then, Function onTimeout, Number timeout])

等待直到与提供的选择器匹配的元素在dom中可见。

#### waitWhileVisible()
**调用方式**： waitWhileVisible(String selecto\[, Function then, Function onTimeout, Number timeout])

等待与提供选择器匹配的元素由可见变为不可见并执行下一步骤：
```js
var casper = require('casper').create();

casper.start('https://www.example.com/').thenClick('html body div p a', function () {
    this.waitWhileVisible('body > div:nth-child(1) > p:nth-child(2)', function () {
        this.echo("The selected element existed in previous page but doesn't exist in this page.");
    })
}).run();
```

####  warn()
**调用方式**： warn(String message)

在标准输出中输出一条警告信息：
```js
casper.warn("I'm a warning message.");
```

> ##### 提示
调用`warn()`函数会触发warn事件。

####  withFrame()
**调用方式**：withFrame(String|Number frameInfo, Function then)

*版本1.0新增*

将主页切换到具有与传递参数相匹配的名称或frame索引号的frame，并处理一个步骤。

页面上下文切换仅持续到步骤执行完成：
```js
casper.start('tests/site/frames.html', function() {
    this.test.assertTitle('FRAMESET TITLE');
});

casper.withFrame('frame1', function() {
    this.test.assertTitle('FRAME TITLE');
});

casper.withFrame(0, function() {
    this.test.assertTitle('FRAME TITLE');
});

casper.then(function() {
    this.test.assertTitle('FRAMESET TITLE');
});
```

####  withPopup()
**调用方式**：withPopup(Mixed popupInfo, Function then)

*版本1.0新增*

将主页面切换到匹配作为参数传递的信息的弹出窗口，并处理一个步骤。页面上下文切换仅持续到步骤执行完成：
```js
casper.start('http://foo.bar/').then(function() {
    this.test.assertTitle('Main page title');
    this.clickLabel('Open me a popup');
});

// this will wait for the popup to be opened and loaded
casper.waitForPopup(/popup\.html$/, function() {
    this.test.assertEquals(this.popups.length, 1);
});

// this will set the popup DOM as the main active one only for time the
// step closure being executed
casper.withPopup(/popup\.html$/, function() {
    this.test.assertTitle('Popup title');
});

// this will set the popup DOM as the main active one only for time the
// step closure being executed
casper.withPopup(0, function() {
    this.test.assertTitle('Popup title');
});

// this will set the popup DOM as the main active one only for time the
// step closure being executed
casper.withPopup({windowName: "mainPopup", title:'Popup title', url:'http://foo.bar/'}, function() {
    this.test.assertTitle('Popup title');
});

// next step will automatically revert the current page to the initial one
casper.then(function() {
    this.test.assertTitle('Main page title');
});
```

> ##### 提示
当前加载的弹出窗口在Casper.popups数组类属性中可用。


####  withSelectorScope()
**调用方式**： withSelectorScope(String selector, Function then)

*版本1.1.5新增*

将主DOM范围切换到特定范围，作为参数传递的信息，并处理一个步骤。它的范围上下文切换只能持续到步执行完成：
```
.. index:: Zoom
```

####  zoom()
**调用方式**: zoom(Number factor)

*版本1.0新增*

设置当前页面缩放系数:
```js
var casper = require('casper').create();

casper.start().zoom(2).thenOpen('http://google.com', function() {
    this.capture('big-google.png');
});

casper.run();
```